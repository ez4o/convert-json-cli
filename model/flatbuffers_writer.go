package model

import "os"

type FlatbuffersWriter struct {
	outputPath string
}

func (fw *FlatbuffersWriter) SetOutputPath(outputPath string) {
	fw.outputPath = outputPath
}

func (fw *FlatbuffersWriter) SetNested(nested bool) {}

func (fw *FlatbuffersWriter) Write(abstractStructs []Struct) error {
	file, err := os.Create(fw.outputPath)
	if err != nil {
		return err
	}
	defer file.Close()

	_, err = file.WriteString("namespace Mygame;\n\n")
	if err != nil {
		return err
	}

	for _, abstractStruct := range abstractStructs {
		if abstractStruct.Name == "Nested" {
			continue
		}

		_, err := file.WriteString(fw.GetStruct(abstractStruct))
		if err != nil {
			return err
		}
	}

	_, err = file.WriteString("root_type AutoGenerated;\n\n")
	if err != nil {
		return err
	}

	return nil
}

func (fw *FlatbuffersWriter) GetStruct(abstractStruct Struct) string {
	return "table " + abstractStruct.Name + " {\n" + fw.GetFields(abstractStruct.Fields) + "}\n\n"
}

func (fw *FlatbuffersWriter) GetFields(fields []Field) string {
	var result string = ""

	for i, field := range fields {
		result += fw.GetField(i, field)
	}

	return result
}

func (fw *FlatbuffersWriter) GetField(_ int, field Field) string {
	typeName := ""

	if field.TypeName[len(field.TypeName)-2:] == "[]" {
		typeName = fw.GetTypeName(field.TypeName[:len(field.TypeName)-2])
	} else {
		typeName = fw.GetTypeName(field.TypeName)
	}

	return "\t"  + field.Index + ":" + typeName  + ";\n"
}

func (fw *FlatbuffersWriter) GetTypeName(typeName string) string {
	switch typeName {
	case "int16":
		return "short"
	case "int32":
		return "int"
	case "int64":
		return "long"
	case "string":
		return "string"
	case "bool":
		return "bool"
	case "float32":
		return "float"
	case "float64":
		return "double"
	default:
		return "[" + typeName + "]"
	}
}
